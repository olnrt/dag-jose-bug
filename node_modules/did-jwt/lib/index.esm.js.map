{"version":3,"file":"index.esm.js","sources":["../src/util.ts","../src/Digest.ts","../src/signers/ES256KSigner.ts","../src/signers/SimpleSigner.ts","../src/signers/EllipticSigner.ts","../src/signers/EdDSASigner.ts","../src/signers/NaclSigner.ts","../src/SignerAlgorithm.ts","../src/VerifierAlgorithm.ts","../src/JWT.ts","../src/JWE.ts","../src/xc20pEncryption.ts"],"sourcesContent":["import * as u8a from 'uint8arrays'\n\n/**\n * @deprecated Signers will be expected to return base64url `string` signatures.\n */\nexport interface EcdsaSignature {\n  r: string\n  s: string\n  recoveryParam?: number\n}\n\nexport function bytesToBase64url(b: Uint8Array): string {\n  return u8a.toString(b, 'base64url')\n}\n\nexport function base64ToBytes(s: string): Uint8Array {\n  const inputBase64Url = s.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '')\n  return u8a.fromString(inputBase64Url, 'base64url')\n}\n\nexport function bytesToBase64(b: Uint8Array): string {\n  return u8a.toString(b, 'base64pad')\n}\n\nexport function base58ToBytes(s: string): Uint8Array {\n  return u8a.fromString(s, 'base58btc')\n}\n\nexport function bytesToBase58(b: Uint8Array): string {\n  return u8a.toString(b, 'base58btc')\n}\n\nexport function hexToBytes(s: string): Uint8Array {\n  const input = s.startsWith('0x') ? s.substring(2) : s\n  return u8a.fromString(input.toLowerCase(), 'base16')\n}\n\nexport function encodeBase64url(s: string): string {\n  return bytesToBase64url(u8a.fromString(s))\n}\n\nexport function decodeBase64url(s: string): string {\n  return u8a.toString(base64ToBytes(s))\n}\n\nexport function bytesToHex(b: Uint8Array): string {\n  return u8a.toString(b, 'base16')\n}\n\nexport function stringToBytes(s: string): Uint8Array {\n  return u8a.fromString(s)\n}\n\nexport function toJose({ r, s, recoveryParam }: EcdsaSignature, recoverable?: boolean): string {\n  const jose = new Uint8Array(recoverable ? 65 : 64)\n  jose.set(u8a.fromString(r, 'base16'), 0)\n  jose.set(u8a.fromString(s, 'base16'), 32)\n  if (recoverable) {\n    if (recoveryParam === undefined) {\n      throw new Error('Signer did not return a recoveryParam')\n    }\n    jose[64] = recoveryParam\n  }\n  return bytesToBase64url(jose)\n}\n\nexport function fromJose(signature: string): { r: string; s: string; recoveryParam: number } {\n  const signatureBytes: Uint8Array = base64ToBytes(signature)\n  if (signatureBytes.length < 64 || signatureBytes.length > 65) {\n    throw new TypeError(`Wrong size for signature. Expected 64 or 65 bytes, but got ${signatureBytes.length}`)\n  }\n  const r = bytesToHex(signatureBytes.slice(0, 32))\n  const s = bytesToHex(signatureBytes.slice(32, 64))\n  const recoveryParam = signatureBytes.length === 65 ? signatureBytes[64] : undefined\n  return { r, s, recoveryParam }\n}\n\nexport function toSealed(ciphertext: string, tag: string): Uint8Array {\n  return u8a.concat([base64ToBytes(ciphertext), base64ToBytes(tag)])\n}\n\nconst hexMatcher = /^(0x)?([a-fA-F0-9]{64}|[a-fA-F0-9]{128})$/\nconst base58Matcher = /^([1-9A-HJ-NP-Za-km-z]{44}|[1-9A-HJ-NP-Za-km-z]{88})$/\nconst base64Matcher = /^([0-9a-zA-Z=\\-_\\+\\/]{43}|[0-9a-zA-Z=\\-_\\+\\/]{86})(={0,2})$/\n\n/**\n * Parses a private key and returns the Uint8Array representation.\n * This method uses an heuristic to determine the key encoding to then be able to parse it into 32 or 64 bytes.\n *\n * @param input a 32 or 64 byte key presented either as a Uint8Array or as a hex, base64, or base58btc encoded string\n *\n * @throws TypeError('Invalid private key format') if the key doesn't match any of the accepted formats or length\n */\nexport function parseKey(input: string | Uint8Array): Uint8Array {\n  if (typeof input === 'string') {\n    if (hexMatcher.test(input)) {\n      return hexToBytes(input)\n    } else if (base58Matcher.test(input)) {\n      return base58ToBytes(input)\n    } else if (base64Matcher.test(input)) {\n      return base64ToBytes(input)\n    } else {\n      throw TypeError('Invalid private key format')\n    }\n  } else if (input instanceof Uint8Array) {\n    return input\n  } else {\n    throw TypeError('Invalid private key format')\n  }\n}\n\nexport function leftpad(data: string, size = 64): string {\n  if (data.length === size) return data\n  return '0'.repeat(size - data.length) + data\n}\n","import { hash } from '@stablelib/sha256'\nimport * as u8a from 'uint8arrays'\nimport { keccak_256 } from 'js-sha3' // eslint-disable-line\n\nexport function sha256(payload: string | Uint8Array): Uint8Array {\n  const data = typeof payload === 'string' ? u8a.fromString(payload) : payload\n  return hash(data)\n}\n\nexport function keccak(data: Uint8Array): Uint8Array {\n  return new Uint8Array(keccak_256.arrayBuffer(data))\n}\n\nexport function toEthereumAddress(hexPublicKey: string): string {\n  const hashInput = u8a.fromString(hexPublicKey.slice(2), 'base16')\n  return `0x${u8a.toString(keccak(hashInput).slice(-20), 'base16')}`\n}\n\nfunction writeUint32BE(value: number, array = new Uint8Array(4)): Uint8Array {\n  const encoded = u8a.fromString(value.toString(), 'base10')\n  array.set(encoded, 4 - encoded.length)\n  return array\n}\n\nconst lengthAndInput = (input: Uint8Array): Uint8Array => u8a.concat([writeUint32BE(input.length), input])\n\n// This implementation of concatKDF was inspired by these two implementations:\n// https://github.com/digitalbazaar/minimal-cipher/blob/master/algorithms/ecdhkdf.js\n// https://github.com/panva/jose/blob/master/lib/jwa/ecdh/derive.js\nexport function concatKDF(\n  secret: Uint8Array,\n  keyLen: number,\n  alg: string,\n  producerInfo?: Uint8Array,\n  consumerInfo?: Uint8Array\n): Uint8Array {\n  if (keyLen !== 256) throw new Error(`Unsupported key length: ${keyLen}`)\n  const value = u8a.concat([\n    lengthAndInput(u8a.fromString(alg)),\n    lengthAndInput(typeof producerInfo === 'undefined' ? new Uint8Array(0) : producerInfo), // apu\n    lengthAndInput(typeof consumerInfo === 'undefined' ? new Uint8Array(0) : consumerInfo), // apv\n    writeUint32BE(keyLen)\n  ])\n\n  // since our key lenght is 256 we only have to do one round\n  const roundNumber = 1\n  return hash(u8a.concat([writeUint32BE(roundNumber), secret, value]))\n}\n","import { parseKey, leftpad } from '../util'\nimport { toJose } from '../util'\nimport { Signer } from '../JWT'\nimport { sha256 } from '../Digest'\n\nimport { ec as EC, ec } from 'elliptic'\nconst secp256k1: EC = new EC('secp256k1')\n\n/**\n *  Creates a configured signer function for signing data using the ES256K (secp256k1 + sha256) algorithm.\n *\n *  The signing function itself takes the data as a `Uint8Array` or `string` and returns a `base64Url`-encoded signature\n *\n *  @example\n *  ```typescript\n *  const sign: Signer = ES256KSigner(process.env.PRIVATE_KEY)\n *  const signature: string = await sign(data)\n *  ```\n *\n *  @param    {String}    privateKey   a private key as `Uint8Array` or encoded as `base64`, `base58`, or `hex` string\n *  @param    {Boolean}   recoverable  an optional flag to add the recovery param to the generated signatures\n *  @return   {Function}               a configured signer function `(data: string | Uint8Array): Promise<string>`\n */\nexport function ES256KSigner(privateKey: string | Uint8Array, recoverable: boolean = false): Signer {\n  const privateKeyBytes: Uint8Array = parseKey(privateKey)\n  if (privateKeyBytes.length !== 32) {\n    throw new Error(`Invalid private key format. Expecting 32 bytes, but got ${privateKeyBytes.length}`)\n  }\n  const keyPair: ec.KeyPair = secp256k1.keyFromPrivate(privateKeyBytes)\n\n  return async (data: string | Uint8Array): Promise<string> => {\n    const { r, s, recoveryParam }: EC.Signature = keyPair.sign(sha256(data))\n    return toJose(\n      {\n        r: leftpad(r.toString('hex')),\n        s: leftpad(s.toString('hex')),\n        recoveryParam\n      },\n      recoverable\n    )\n  }\n}\n","import { fromJose } from '../util'\nimport { Signer } from '../JWT'\nimport { ES256KSigner } from './ES256KSigner'\n\n/**\n * @deprecated Please use ES256KSigner\n *  The SimpleSigner returns a configured function for signing data.\n *\n *  @example\n *  const signer = SimpleSigner(process.env.PRIVATE_KEY)\n *  signer(data, (err, signature) => {\n *    ...\n *  })\n *\n *  @param    {String}         hexPrivateKey    a hex encoded private key\n *  @return   {Function}                     a configured signer function\n */\nfunction SimpleSigner(hexPrivateKey: string): Signer {\n  const signer = ES256KSigner(hexPrivateKey, true)\n  return async (data) => {\n    const signature = (await signer(data)) as string\n    return fromJose(signature)\n  }\n}\n\nexport default SimpleSigner\n","import { Signer } from '../JWT'\nimport { ES256KSigner } from './ES256KSigner'\n\n/**\n * @deprecated Please use ES256KSigner\n *  The EllipticSigner returns a configured function for signing data.\n *\n *  @example\n *  ```typescript\n *  const signer = EllipticSigner(process.env.PRIVATE_KEY)\n *  signer(data).then( (signature: string) => {\n *    ...\n *  })\n *  ```\n *\n *  @param    {String}         hexPrivateKey    a hex encoded private key\n *  @return   {Function}                        a configured signer function\n */\nfunction EllipticSigner(hexPrivateKey: string): Signer {\n  return ES256KSigner(hexPrivateKey)\n}\n\nexport default EllipticSigner\n","import { sign } from '@stablelib/ed25519'\nimport { Signer } from '../JWT'\nimport { bytesToBase64url, parseKey, stringToBytes } from '../util'\n\n/**\n *  Creates a configured signer function for signing data using the EdDSA (Ed25519) algorithm.\n *\n *  The signing function itself takes the data as a `Uint8Array` or `string` and returns a `base64Url`-encoded signature\n *\n *  @example\n *  ```typescript\n *  const sign: Signer = EdDSASigner(process.env.PRIVATE_KEY)\n *  const signature: string = await sign(data)\n *  ```\n *\n *  @param    {String}    secretKey   a 64 byte secret key as `Uint8Array` or encoded as `base64`, `base58`, or `hex` string\n *  @return   {Function}              a configured signer function `(data: string | Uint8Array): Promise<string>`\n */\nexport function EdDSASigner(secretKey: string | Uint8Array): Signer {\n  const privateKeyBytes: Uint8Array = parseKey(secretKey)\n  if (privateKeyBytes.length !== 64) {\n    throw new Error(`Invalid private key format. Expecting 64 bytes, but got ${privateKeyBytes.length}`)\n  }\n  return async (data: string | Uint8Array): Promise<string> => {\n    const dataBytes: Uint8Array = typeof data === 'string' ? stringToBytes(data) : data\n    const sig: Uint8Array = sign(privateKeyBytes, dataBytes)\n    return bytesToBase64url(sig)\n  }\n}\n","import { EdDSASigner as EdDSASigner } from './EdDSASigner'\nimport { Signer } from '../JWT'\n\n/**\n * @deprecated Please use EdDSASigner\n *\n *  The NaclSigner returns a configured function for signing data using the Ed25519 algorithm.\n *\n *  The signing function itself takes the data as a `string` or `Uint8Array` parameter and returns a `base64Url`-encoded signature.\n *\n *  @example\n *  const signer = NaclSigner(process.env.PRIVATE_KEY)\n *  const data: string = '...'\n *  signer(data).then( (signature: string) => {\n *    ...\n *  })\n *\n *  @param    {String}   base64PrivateKey    a 64 byte base64 encoded private key\n *  @return   {Function}                     a configured signer function\n */\n\nfunction NaclSigner(base64PrivateKey: string): Signer {\n  return EdDSASigner(base64PrivateKey)\n}\n\nexport default NaclSigner\n","import { Signer, SignerAlgorithm } from './JWT'\nimport { EcdsaSignature, fromJose, toJose } from './util'\n\nfunction instanceOfEcdsaSignature(object: any): object is EcdsaSignature {\n  return typeof object === 'object' && 'r' in object && 's' in object\n}\n\nexport function ES256KSignerAlg(recoverable?: boolean): SignerAlgorithm {\n  return async function sign(payload: string, signer: Signer): Promise<string> {\n    const signature: EcdsaSignature | string = await signer(payload)\n    if (instanceOfEcdsaSignature(signature)) {\n      return toJose(signature, recoverable)\n    } else {\n      if (recoverable && typeof fromJose(signature).recoveryParam === 'undefined') {\n        throw new Error(`ES256K-R not supported when signer doesn't provide a recovery param`)\n      }\n      return signature\n    }\n  }\n}\n\nexport function Ed25519SignerAlg(): SignerAlgorithm {\n  return async function sign(payload: string, signer: Signer): Promise<string> {\n    const signature: EcdsaSignature | string = await signer(payload)\n    if (!instanceOfEcdsaSignature(signature)) {\n      return signature\n    } else {\n      throw new Error('expected a signer function that returns a string instead of signature object')\n    }\n  }\n}\n\ninterface SignerAlgorithms {\n  [alg: string]: SignerAlgorithm\n}\n\nconst algorithms: SignerAlgorithms = {\n  ES256K: ES256KSignerAlg(),\n  // This is a non-standard algorithm but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/146\n  'ES256K-R': ES256KSignerAlg(true),\n  // This is actually incorrect but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/130\n  Ed25519: Ed25519SignerAlg(),\n  EdDSA: Ed25519SignerAlg()\n}\n\nfunction SignerAlg(alg: string): SignerAlgorithm {\n  const impl: SignerAlgorithm = algorithms[alg]\n  if (!impl) throw new Error(`Unsupported algorithm ${alg}`)\n  return impl\n}\n\nexport default SignerAlg\n","import { ec as EC } from 'elliptic'\nimport { sha256, toEthereumAddress } from './Digest'\nimport { verify } from '@stablelib/ed25519'\nimport type { VerificationMethod } from 'did-resolver'\nimport { hexToBytes, base58ToBytes, base64ToBytes, bytesToHex, EcdsaSignature, stringToBytes } from './util'\n\nconst secp256k1 = new EC('secp256k1')\n\n// converts a JOSE signature to it's components\nexport function toSignatureObject(signature: string, recoverable = false): EcdsaSignature {\n  const rawsig: Uint8Array = base64ToBytes(signature)\n  if (rawsig.length !== (recoverable ? 65 : 64)) {\n    throw new Error('wrong signature length')\n  }\n  const r: string = bytesToHex(rawsig.slice(0, 32))\n  const s: string = bytesToHex(rawsig.slice(32, 64))\n  const sigObj: EcdsaSignature = { r, s }\n  if (recoverable) {\n    sigObj.recoveryParam = rawsig[64]\n  }\n  return sigObj\n}\n\ninterface LegacyVerificationMethod extends VerificationMethod {\n  publicKeyBase64: string\n}\n\nfunction extractPublicKeyBytes(pk: VerificationMethod): Uint8Array {\n  if (pk.publicKeyBase58) {\n    return base58ToBytes(pk.publicKeyBase58)\n  } else if ((<LegacyVerificationMethod>pk).publicKeyBase64) {\n    return base64ToBytes((<LegacyVerificationMethod>pk).publicKeyBase64)\n  } else if (pk.publicKeyHex) {\n    return hexToBytes(pk.publicKeyHex)\n  } else if (pk.publicKeyJwk && pk.publicKeyJwk.crv === 'secp256k1') {\n    return hexToBytes(\n      secp256k1\n        .keyFromPublic({\n          x: bytesToHex(base64ToBytes(pk.publicKeyJwk.x)),\n          y: bytesToHex(base64ToBytes(pk.publicKeyJwk.y))\n        })\n        .getPublic('hex')\n    )\n  }\n  return new Uint8Array()\n}\n\nexport function verifyES256K(\n  data: string,\n  signature: string,\n  authenticators: VerificationMethod[]\n): VerificationMethod {\n  const hash: Uint8Array = sha256(data)\n  const sigObj: EcdsaSignature = toSignatureObject(signature)\n  const fullPublicKeys = authenticators.filter(({ ethereumAddress, blockchainAccountId }) => {\n    return typeof ethereumAddress === 'undefined' && typeof blockchainAccountId === 'undefined'\n  })\n  const ethAddressKeys = authenticators.filter(({ ethereumAddress, blockchainAccountId }) => {\n    return typeof ethereumAddress !== 'undefined' || typeof blockchainAccountId !== undefined\n  })\n\n  let signer: VerificationMethod = fullPublicKeys.find((pk: VerificationMethod) => {\n    try {\n      const pubBytes = extractPublicKeyBytes(pk)\n      return secp256k1.keyFromPublic(pubBytes).verify(hash, sigObj)\n    } catch (err) {\n      return false\n    }\n  })\n\n  if (!signer && ethAddressKeys.length > 0) {\n    signer = verifyRecoverableES256K(data, signature, ethAddressKeys)\n  }\n\n  if (!signer) throw new Error('Signature invalid for JWT')\n  return signer\n}\n\nexport function verifyRecoverableES256K(\n  data: string,\n  signature: string,\n  authenticators: VerificationMethod[]\n): VerificationMethod {\n  let signatures: EcdsaSignature[]\n  if (signature.length > 86) {\n    signatures = [toSignatureObject(signature, true)]\n  } else {\n    const so = toSignatureObject(signature, false)\n    signatures = [\n      { ...so, recoveryParam: 0 },\n      { ...so, recoveryParam: 1 }\n    ]\n  }\n\n  const checkSignatureAgainstSigner = (sigObj: EcdsaSignature): VerificationMethod => {\n    const hash: Uint8Array = sha256(data)\n    const recoveredKey: any = secp256k1.recoverPubKey(hash, sigObj, sigObj.recoveryParam)\n    const recoveredPublicKeyHex: string = recoveredKey.encode('hex')\n    const recoveredCompressedPublicKeyHex: string = recoveredKey.encode('hex', true)\n    const recoveredAddress: string = toEthereumAddress(recoveredPublicKeyHex)\n\n    const signer: VerificationMethod = authenticators.find((pk: VerificationMethod) => {\n      const keyHex = bytesToHex(extractPublicKeyBytes(pk))\n      return (\n        keyHex === recoveredPublicKeyHex ||\n        keyHex === recoveredCompressedPublicKeyHex ||\n        pk.ethereumAddress?.toLowerCase() === recoveredAddress ||\n        pk.blockchainAccountId?.split('@eip155')?.[0].toLowerCase() === recoveredAddress\n      )\n    })\n\n    return signer\n  }\n\n  const signer: VerificationMethod[] = signatures.map(checkSignatureAgainstSigner).filter((key) => key != null)\n\n  if (signer.length === 0) throw new Error('Signature invalid for JWT')\n  return signer[0]\n}\n\nexport function verifyEd25519(\n  data: string,\n  signature: string,\n  authenticators: VerificationMethod[]\n): VerificationMethod {\n  const clear: Uint8Array = stringToBytes(data)\n  const sig: Uint8Array = base64ToBytes(signature)\n  const signer: VerificationMethod = authenticators.find((pk: VerificationMethod) => {\n    return verify(extractPublicKeyBytes(pk), clear, sig)\n  })\n  if (!signer) throw new Error('Signature invalid for JWT')\n  return signer\n}\n\ntype Verifier = (data: string, signature: string, authenticators: VerificationMethod[]) => VerificationMethod\ninterface Algorithms {\n  [name: string]: Verifier\n}\nconst algorithms: Algorithms = {\n  ES256K: verifyES256K,\n  // This is a non-standard algorithm but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/146\n  'ES256K-R': verifyRecoverableES256K,\n  // This is actually incorrect but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/130\n  Ed25519: verifyEd25519,\n  EdDSA: verifyEd25519\n}\n\nfunction VerifierAlgorithm(alg: string): Verifier {\n  const impl: Verifier = algorithms[alg]\n  if (!impl) throw new Error(`Unsupported algorithm ${alg}`)\n  return impl\n}\n\nVerifierAlgorithm.toSignatureObject = toSignatureObject\n\nexport default VerifierAlgorithm\n","import canonicalizeData from 'canonicalize'\nimport type { DIDDocument, DIDResolutionResult, Resolvable, VerificationMethod } from 'did-resolver'\nimport SignerAlg from './SignerAlgorithm'\nimport { decodeBase64url, EcdsaSignature, encodeBase64url } from './util'\nimport VerifierAlgorithm from './VerifierAlgorithm'\n\nexport type Signer = (data: string | Uint8Array) => Promise<EcdsaSignature | string>\nexport type SignerAlgorithm = (payload: string, signer: Signer) => Promise<string>\n\nexport interface JWTOptions {\n  issuer: string\n  signer: Signer\n  /**\n   * @deprecated Please use `header.alg` to specify the JWT algorithm.\n   */\n  alg?: string\n  expiresIn?: number\n  canonicalize?: boolean\n}\n\nexport interface JWTVerifyOptions {\n  /** @deprecated Please use `proofPurpose: 'authentication' instead` */\n  auth?: boolean\n  audience?: string\n  callbackUrl?: string\n  resolver?: Resolvable\n  skewTime?: number\n  /** See https://www.w3.org/TR/did-spec-registries/#verification-relationships */\n  proofPurpose?: 'authentication' | 'assertionMethod' | 'capabilityDelegation' | 'capabilityInvocation' | string\n}\n\nexport interface JWSCreationOptions {\n  canonicalize?: boolean\n}\n\nexport interface DIDAuthenticator {\n  authenticators: VerificationMethod[]\n  issuer: string\n  didResolutionResult: DIDResolutionResult\n}\n\nexport interface JWTHeader {\n  typ: 'JWT'\n  alg: string\n  [x: string]: any\n}\n\nexport interface JWTPayload {\n  iss?: string\n  sub?: string\n  aud?: string | string[]\n  iat?: number\n  nbf?: number\n  type?: string\n  exp?: number\n  rexp?: number\n  [x: string]: any\n}\n\nexport interface JWTDecoded {\n  header: JWTHeader\n  payload: JWTPayload\n  signature: string\n  data: string\n}\n\nexport interface JWSDecoded {\n  header: JWTHeader\n  payload: string\n  signature: string\n  data: string\n}\n\nexport interface JWTVerified {\n  payload: any\n  didResolutionResult: DIDResolutionResult\n  issuer: string\n  signer: object\n  jwt: string\n}\n\nexport interface PublicKeyTypes {\n  [name: string]: string[]\n}\nexport const SUPPORTED_PUBLIC_KEY_TYPES: PublicKeyTypes = {\n  ES256K: [\n    'EcdsaSecp256k1VerificationKey2019',\n    /**\n     * Equivalent to EcdsaSecp256k1VerificationKey2019 when key is an ethereumAddress\n     */\n    'EcdsaSecp256k1RecoveryMethod2020',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\n     */\n    'Secp256k1VerificationKey2018',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\n     */\n    'Secp256k1SignatureVerificationKey2018',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\n     */\n    'EcdsaPublicKeySecp256k1'\n  ],\n  'ES256K-R': [\n    'EcdsaSecp256k1VerificationKey2019',\n    /**\n     * Equivalent to EcdsaSecp256k1VerificationKey2019 when key is an ethereumAddress\n     */\n    'EcdsaSecp256k1RecoveryMethod2020',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\n     */\n    'Secp256k1VerificationKey2018',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\n     */\n    'Secp256k1SignatureVerificationKey2018',\n    /**\n     * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is not an ethereumAddress\n     */\n    'EcdsaPublicKeySecp256k1'\n  ],\n  Ed25519: ['ED25519SignatureVerification', 'Ed25519VerificationKey2018'],\n  EdDSA: ['ED25519SignatureVerification', 'Ed25519VerificationKey2018']\n}\n\nconst defaultAlg = 'ES256K'\nconst DID_JSON = 'application/did+json'\n\nfunction encodeSection(data: any, shouldCanonicalize: boolean = false): string {\n  if (shouldCanonicalize) {\n    return encodeBase64url(canonicalizeData(data))\n  } else {\n    return encodeBase64url(JSON.stringify(data))\n  }\n}\n\nexport const NBF_SKEW: number = 300\n\nfunction decodeJWS(jws: string): JWSDecoded {\n  const parts: RegExpMatchArray = jws.match(/^([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)$/)\n  if (parts) {\n    return {\n      header: JSON.parse(decodeBase64url(parts[1])),\n      payload: parts[2],\n      signature: parts[3],\n      data: `${parts[1]}.${parts[2]}`\n    }\n  }\n  throw new Error('Incorrect format JWS')\n}\n\n/**  @module did-jwt/JWT */\n\n/**\n *  Decodes a JWT and returns an object representing the payload\n *\n *  @example\n *  decodeJWT('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJpYXQiOjE1...')\n *\n *  @param    {String}            jwt                a JSON Web Token to verify\n *  @return   {Object}                               a JS object representing the decoded JWT\n */\nexport function decodeJWT(jwt: string): JWTDecoded {\n  if (!jwt) throw new Error('no JWT passed into decodeJWT')\n  try {\n    const jws = decodeJWS(jwt)\n    const decodedJwt: JWTDecoded = Object.assign(jws, { payload: JSON.parse(decodeBase64url(jws.payload)) })\n    return decodedJwt\n  } catch (e) {\n    throw new Error('Incorrect format JWT')\n  }\n}\n\n/**\n *  Creates a signed JWS given a payload, a signer, and an optional header.\n *\n *  @example\n *  const signer = ES256KSigner(process.env.PRIVATE_KEY)\n *  const jws = await createJWS({ my: 'payload' }, signer)\n *\n *  @param    {Object}            payload           payload object\n *  @param    {Signer}            signer            a signer, see `ES256KSigner or `EdDSASigner`\n *  @param    {Object}            header            optional object to specify or customize the JWS header\n *  @return   {Promise<Object, Error>}              a promise which resolves with a JWS string or rejects with an error\n */\nexport async function createJWS(\n  payload: string | any,\n  signer: Signer,\n  header: Partial<JWTHeader> = {},\n  options: JWSCreationOptions = {}\n): Promise<string> {\n  if (!header.alg) header.alg = defaultAlg\n  const encodedPayload = typeof payload === 'string' ? payload : encodeSection(payload, options.canonicalize)\n  const signingInput: string = [encodeSection(header, options.canonicalize), encodedPayload].join('.')\n\n  const jwtSigner: SignerAlgorithm = SignerAlg(header.alg)\n  const signature: string = await jwtSigner(signingInput, signer)\n  return [signingInput, signature].join('.')\n}\n\n/**\n *  Creates a signed JWT given an address which becomes the issuer, a signer, and a payload for which the signature is over.\n *\n *  @example\n *  const signer = ES256KSigner(process.env.PRIVATE_KEY)\n *  createJWT({address: '5A8bRWU3F7j3REx3vkJ...', signer}, {key1: 'value', key2: ..., ... }).then(jwt => {\n *      ...\n *  })\n *\n *  @param    {Object}            payload               payload object\n *  @param    {Object}            [options]             an unsigned credential object\n *  @param    {String}            options.issuer        The DID of the issuer (signer) of JWT\n *  @param    {String}            options.alg           [DEPRECATED] The JWT signing algorithm to use. Supports: [ES256K, ES256K-R, Ed25519, EdDSA], Defaults to: ES256K.\n *                                                      Please use `header.alg` to specify the algorithm\n *  @param    {Signer}            options.signer        a `Signer` function, Please see `ES256KSigner` or `EdDSASigner`\n *  @param    {boolean}           options.canonicalize  optional flag to canonicalize header and payload before signing\n *  @param    {Object}            header                optional object to specify or customize the JWT header\n *  @return   {Promise<Object, Error>}                  a promise which resolves with a signed JSON Web Token or rejects with an error\n */\nexport async function createJWT(\n  payload: any,\n  { issuer, signer, alg, expiresIn, canonicalize }: JWTOptions,\n  header: Partial<JWTHeader> = {}\n): Promise<string> {\n  if (!signer) throw new Error('No Signer functionality has been configured')\n  if (!issuer) throw new Error('No issuing DID has been configured')\n  if (!header.typ) header.typ = 'JWT'\n  if (!header.alg) header.alg = alg\n  const timestamps: Partial<JWTPayload> = {\n    iat: Math.floor(Date.now() / 1000),\n    exp: undefined\n  }\n  if (expiresIn) {\n    if (typeof expiresIn === 'number') {\n      timestamps.exp = (payload.nbf || timestamps.iat) + Math.floor(expiresIn)\n    } else {\n      throw new Error('JWT expiresIn is not a number')\n    }\n  }\n  const fullPayload = { ...timestamps, ...payload, iss: issuer }\n  return createJWS(fullPayload, signer, header, { canonicalize })\n}\n\nfunction verifyJWSDecoded(\n  { header, data, signature }: JWSDecoded,\n  pubkeys: VerificationMethod | VerificationMethod[]\n): VerificationMethod {\n  if (!Array.isArray(pubkeys)) pubkeys = [pubkeys]\n  const signer: VerificationMethod = VerifierAlgorithm(header.alg)(data, signature, pubkeys)\n  return signer\n}\n\n/**\n *  Verifies given JWS. If the JWS is valid, returns the public key that was\n *  used to sign the JWS, or throws an `Error` if none of the `pubkeys` match.\n *\n *  @example\n *  const pubkey = verifyJWT('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', { publicKeyHex: '0x12341...' })\n *\n *  @param    {String}                          jws         A JWS string to verify\n *  @param    {Array<VerificationMethod> | VerificationMethod}    pubkeys     The public keys used to verify the JWS\n *  @return   {VerificationMethod}                       The public key used to sign the JWS\n */\nexport function verifyJWS(jws: string, pubkeys: VerificationMethod | VerificationMethod[]): VerificationMethod {\n  const jwsDecoded: JWSDecoded = decodeJWS(jws)\n  return verifyJWSDecoded(jwsDecoded, pubkeys)\n}\n\n/**\n *  Verifies given JWT. If the JWT is valid, the promise returns an object including the JWT, the payload of the JWT,\n *  and the did doc of the issuer of the JWT.\n *\n *  @example\n *  verifyJWT('did:uport:eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', {audience: '5A8bRWU3F7j3REx3vkJ...', callbackUrl: 'https://...'}).then(obj => {\n *      const did = obj.did // DID of signer\n *      const payload = obj.payload\n *      const doc = obj.doc // DID Document of signer\n *      const jwt = obj.jwt\n *      const signerKeyId = obj.signerKeyId // ID of key in DID document that signed JWT\n *      ...\n *  })\n *\n *  @param    {String}            jwt                a JSON Web Token to verify\n *  @param    {Object}            [options]           an unsigned credential object\n *  @param    {Boolean}           options.auth        Require signer to be listed in the authentication section of the DID document (for Authentication purposes)\n *  @param    {String}            options.audience    DID of the recipient of the JWT\n *  @param    {String}            options.callbackUrl callback url in JWT\n *  @return   {Promise<Object, Error>}               a promise which resolves with a response object or rejects with an error\n */\nexport async function verifyJWT(\n  jwt: string,\n  options: JWTVerifyOptions = {\n    resolver: null,\n    auth: null,\n    audience: null,\n    callbackUrl: null,\n    skewTime: null,\n    proofPurpose: null\n  }\n): Promise<JWTVerified> {\n  if (!options.resolver) throw new Error('No DID resolver has been configured')\n  const { payload, header, signature, data }: JWTDecoded = decodeJWT(jwt)\n  const proofPurpose: string | undefined = options.hasOwnProperty('auth')\n    ? options.auth\n      ? 'authentication'\n      : undefined\n    : options.proofPurpose\n  const { didResolutionResult, authenticators, issuer }: DIDAuthenticator = await resolveAuthenticator(\n    options.resolver,\n    header.alg,\n    payload.iss,\n    proofPurpose\n  )\n  const signer: VerificationMethod = await verifyJWSDecoded({ header, data, signature } as JWSDecoded, authenticators)\n  const now: number = Math.floor(Date.now() / 1000)\n  const skewTime = options.skewTime >= 0 ? options.skewTime : NBF_SKEW\n  if (signer) {\n    const nowSkewed = now + skewTime\n    if (payload.nbf) {\n      if (payload.nbf > nowSkewed) {\n        throw new Error(`JWT not valid before nbf: ${payload.nbf}`)\n      }\n    } else if (payload.iat && payload.iat > nowSkewed) {\n      throw new Error(`JWT not valid yet (issued in the future) iat: ${payload.iat}`)\n    }\n    if (payload.exp && payload.exp <= now - skewTime) {\n      throw new Error(`JWT has expired: exp: ${payload.exp} < now: ${now}`)\n    }\n    if (payload.aud) {\n      if (!options.audience && !options.callbackUrl) {\n        throw new Error('JWT audience is required but your app address has not been configured')\n      }\n      const audArray = Array.isArray(payload.aud) ? payload.aud : [payload.aud]\n      const matchedAudience = audArray.find((item) => options.audience === item || options.callbackUrl === item)\n\n      if (typeof matchedAudience === 'undefined') {\n        throw new Error(`JWT audience does not match your DID or callback url`)\n      }\n    }\n    return { payload, didResolutionResult, issuer, signer, jwt }\n  }\n}\n\n/**\n * Resolves relevant public keys or other authenticating material used to verify signature from the DID document of provided DID\n *\n *  @example\n *  resolveAuthenticator(resolver, 'ES256K', 'did:uport:2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqX').then(obj => {\n *      const payload = obj.payload\n *      const profile = obj.profile\n *      const jwt = obj.jwt\n *      ...\n *  })\n *\n *  @param    {String}            alg                a JWT algorithm\n *  @param    {String}            did                a Decentralized IDentifier (DID) to lookup\n *  @param    {Boolean}           auth               Restrict public keys to ones specifically listed in the 'authentication' section of DID document\n *  @return   {Promise<DIDAuthenticator>}               a promise which resolves with a response object containing an array of authenticators or if non exist rejects with an error\n */\nexport async function resolveAuthenticator(\n  resolver: Resolvable,\n  alg: string,\n  issuer: string,\n  proofPurpose?: string\n): Promise<DIDAuthenticator> {\n  const types: string[] = SUPPORTED_PUBLIC_KEY_TYPES[alg]\n  if (!types || types.length === 0) {\n    throw new Error(`No supported signature types for algorithm ${alg}`)\n  }\n  let didResult: DIDResolutionResult\n\n  const result = (await resolver.resolve(issuer, { accept: DID_JSON })) as unknown\n  // support legacy resolvers that do not produce DIDResolutionResult\n  if (Object.getOwnPropertyNames(result).indexOf('didDocument') === -1) {\n    didResult = {\n      didDocument: result as DIDDocument,\n      didDocumentMetadata: {},\n      didResolutionMetadata: { contentType: DID_JSON }\n    }\n  } else {\n    didResult = result as DIDResolutionResult\n  }\n\n  if (didResult.didResolutionMetadata?.error) {\n    const { error, message } = didResult.didResolutionMetadata\n    throw new Error(`Unable to resolve DID document for ${issuer}: ${error}, ${message || ''}`)\n  }\n\n  const getPublicKeyById = (verificationMethods: VerificationMethod[], pubid: string): VerificationMethod | null => {\n    const filtered = verificationMethods.filter(({ id }) => pubid === id)\n    return filtered.length > 0 ? filtered[0] : null\n  }\n\n  let publicKeysToCheck: VerificationMethod[] = [\n    ...(didResult?.didDocument?.verificationMethod || []),\n    ...(didResult?.didDocument?.publicKey || [])\n  ]\n  if (typeof proofPurpose === 'string') {\n    // support legacy DID Documents that do not list assertionMethod\n    if (proofPurpose.startsWith('assertion') && !didResult.didDocument.hasOwnProperty('assertionMethod')) {\n      didResult.didDocument.assertionMethod = [...publicKeysToCheck.map((pk) => pk.id)]\n    }\n\n    publicKeysToCheck = (didResult.didDocument[proofPurpose] || [])\n      .map((verificationMethod) => {\n        if (typeof verificationMethod === 'string') {\n          return getPublicKeyById(publicKeysToCheck, verificationMethod)\n        } else if (typeof (<any>verificationMethod).publicKey === 'string') {\n          // this is a legacy format\n          return getPublicKeyById(publicKeysToCheck, (<any>verificationMethod).publicKey)\n        } else {\n          return <VerificationMethod>verificationMethod\n        }\n      })\n      .filter((key) => key != null)\n  }\n\n  const authenticators: VerificationMethod[] = publicKeysToCheck.filter(({ type }) =>\n    types.find((supported) => supported === type)\n  )\n\n  if (typeof proofPurpose === 'string' && (!authenticators || authenticators.length === 0)) {\n    throw new Error(\n      `DID document for ${issuer} does not have public keys suitable for ${alg} with ${proofPurpose} purpose`\n    )\n  }\n  if (!authenticators || authenticators.length === 0) {\n    throw new Error(`DID document for ${issuer} does not have public keys for ${alg}`)\n  }\n  return { authenticators, issuer, didResolutionResult: didResult }\n}\n","import { base64ToBytes, bytesToBase64url, decodeBase64url, toSealed } from './util'\n\ninterface RecipientHeader {\n  alg: string\n  iv: string\n  tag: string\n  epk?: Record<string, any> // Ephemeral  Public Key\n  kid?: string\n  apv?: string\n  apu?: string\n}\n\nexport interface Recipient {\n  header: RecipientHeader\n  encrypted_key: string\n}\n\nexport interface JWE {\n  protected: string\n  iv: string\n  ciphertext: string\n  tag: string\n  aad?: string\n  recipients?: Recipient[]\n}\n\nexport interface EncryptionResult {\n  ciphertext: Uint8Array\n  tag: Uint8Array\n  iv: Uint8Array\n  protectedHeader?: string\n  recipient?: Recipient\n  cek?: Uint8Array\n}\n\nexport interface Encrypter {\n  alg: string\n  enc: string\n  encrypt: (cleartext: Uint8Array, protectedHeader: Record<string, any>, aad?: Uint8Array) => Promise<EncryptionResult>\n  encryptCek?: (cek: Uint8Array) => Promise<Recipient>\n}\n\nexport interface Decrypter {\n  alg: string\n  enc: string\n  decrypt: (\n    sealed: Uint8Array,\n    iv: Uint8Array,\n    aad?: Uint8Array,\n    recipient?: Record<string, any>\n  ) => Promise<Uint8Array>\n}\n\nfunction validateJWE(jwe: JWE) {\n  if (!(jwe.protected && jwe.iv && jwe.ciphertext && jwe.tag)) {\n    throw new Error('Invalid JWE')\n  }\n  if (jwe.recipients) {\n    jwe.recipients.map((rec) => {\n      if (!(rec.header && rec.encrypted_key)) {\n        throw new Error('Invalid JWE')\n      }\n    })\n  }\n}\n\nfunction encodeJWE({ ciphertext, tag, iv, protectedHeader, recipient }: EncryptionResult, aad?: Uint8Array): JWE {\n  const jwe: JWE = {\n    protected: protectedHeader,\n    iv: bytesToBase64url(iv),\n    ciphertext: bytesToBase64url(ciphertext),\n    tag: bytesToBase64url(tag)\n  }\n  if (aad) jwe.aad = bytesToBase64url(aad)\n  if (recipient) jwe.recipients = [recipient]\n  return jwe\n}\n\nexport async function createJWE(\n  cleartext: Uint8Array,\n  encrypters: Encrypter[],\n  protectedHeader = {},\n  aad?: Uint8Array\n): Promise<JWE> {\n  if (encrypters[0].alg === 'dir') {\n    if (encrypters.length > 1) throw new Error('Can only do \"dir\" encryption to one key.')\n    const encryptionResult = await encrypters[0].encrypt(cleartext, protectedHeader, aad)\n    return encodeJWE(encryptionResult, aad)\n  } else {\n    const tmpEnc = encrypters[0].enc\n    if (!encrypters.reduce((acc, encrypter) => acc && encrypter.enc === tmpEnc, true)) {\n      throw new Error('Incompatible encrypters passed')\n    }\n    let cek\n    let jwe\n    for (const encrypter of encrypters) {\n      if (!cek) {\n        const encryptionResult = await encrypter.encrypt(cleartext, protectedHeader, aad)\n        cek = encryptionResult.cek\n        jwe = encodeJWE(encryptionResult, aad)\n      } else {\n        jwe.recipients.push(await encrypter.encryptCek(cek))\n      }\n    }\n    return jwe\n  }\n}\n\nexport async function decryptJWE(jwe: JWE, decrypter: Decrypter): Promise<Uint8Array> {\n  validateJWE(jwe)\n  const protHeader = JSON.parse(decodeBase64url(jwe.protected))\n  if (protHeader.enc !== decrypter.enc) throw new Error(`Decrypter does not support: '${protHeader.enc}'`)\n  const sealed = toSealed(jwe.ciphertext, jwe.tag)\n  const aad = new Uint8Array(Buffer.from(jwe.aad ? `${jwe.protected}.${jwe.aad}` : jwe.protected))\n  let cleartext = null\n  if (protHeader.alg === 'dir' && decrypter.alg === 'dir') {\n    cleartext = await decrypter.decrypt(sealed, base64ToBytes(jwe.iv), aad)\n  } else if (!jwe.recipients || jwe.recipients.length === 0) {\n    throw new Error('Invalid JWE')\n  } else {\n    for (let i = 0; !cleartext && i < jwe.recipients.length; i++) {\n      const recipient = jwe.recipients[i]\n      Object.assign(recipient.header, protHeader)\n      if (recipient.header.alg === decrypter.alg) {\n        cleartext = await decrypter.decrypt(sealed, base64ToBytes(jwe.iv), aad, recipient)\n      }\n    }\n  }\n  if (cleartext === null) throw new Error('Failed to decrypt')\n  return cleartext\n}\n","import { XChaCha20Poly1305 } from '@stablelib/xchacha20poly1305'\nimport { generateKeyPair, sharedKey } from '@stablelib/x25519'\nimport { randomBytes } from '@stablelib/random'\nimport { concatKDF } from './Digest'\nimport { bytesToBase64url, base58ToBytes, encodeBase64url, toSealed, base64ToBytes } from './util'\nimport { Recipient, EncryptionResult, Encrypter, Decrypter } from './JWE'\nimport type { VerificationMethod, Resolvable } from 'did-resolver'\n\n// remove when targeting node 11+ or ES2019\nconst flatten = <T>(arrays: T[]) => [].concat.apply([], arrays)\n\nexport type AuthEncryptParams = {\n  kid?: string\n  skid?: string\n  // base64url encoded\n  apu?: string\n  // base64url encoded\n  apv?: string\n}\n\nexport type AnonEncryptParams = {\n  kid?: string\n}\n\n/**\n * Recommended encrypter for authenticated encryption (i.e. sender authentication and requires\n * sender private key to encrypt the data).\n * Uses ECDH-1PU [v3](https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03) and\n * XC20PKW [v2](https://tools.ietf.org/html/draft-amringer-jose-chacha-02).\n *\n * NOTE: ECDH-1PU and XC20PKW are proposed drafts in IETF and not a standard yet and\n * are subject to change as new revisions or until the offical CFRG specification are released.\n */\nexport function createAuthEncrypter(\n  recipientPublicKey: Uint8Array,\n  senderSecretKey: Uint8Array,\n  options: Partial<AuthEncryptParams> = {}\n): Encrypter {\n  return xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2(recipientPublicKey, senderSecretKey, options)\n}\n\n/**\n * Recommended encrypter for anonymous encryption (i.e. no sender authentication).\n * Uses ECDH-ES+XC20PKW [v2](https://tools.ietf.org/html/draft-amringer-jose-chacha-02).\n *\n * NOTE: ECDH-ES+XC20PKW is a proposed draft in IETF and not a standard yet and\n * is subject to change as new revisions or until the offical CFRG specification is released.\n */\nexport function createAnonEncrypter(publicKey: Uint8Array, options: Partial<AnonEncryptParams> = {}): Encrypter {\n  return options !== undefined ? x25519Encrypter(publicKey, options.kid) : x25519Encrypter(publicKey)\n}\n\n/**\n * Recommended decrypter for authenticated encryption (i.e. sender authentication and requires\n * sender public key to decrypt the data).\n * Uses ECDH-1PU [v3](https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03) and\n * XC20PKW [v2](https://tools.ietf.org/html/draft-amringer-jose-chacha-02).\n *\n * NOTE: ECDH-1PU and XC20PKW are proposed drafts in IETF and not a standard yet and\n * are subject to change as new revisions or until the offical CFRG specification are released.\n */\nexport function createAuthDecrypter(recipientSecretKey: Uint8Array, senderPublicKey: Uint8Array): Decrypter {\n  return xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2(recipientSecretKey, senderPublicKey)\n}\n\n/**\n * Recommended decrypter for anonymous encryption (i.e. no sender authentication).\n * Uses ECDH-ES+XC20PKW [v2](https://tools.ietf.org/html/draft-amringer-jose-chacha-02).\n *\n * NOTE: ECDH-ES+XC20PKW is a proposed draft in IETF and not a standard yet and\n * is subject to change as new revisions or until the offical CFRG specification is released.\n */\nexport function createAnonDecrypter(secretKey: Uint8Array): Decrypter {\n  return x25519Decrypter(secretKey)\n}\n\nfunction xc20pEncrypter(key: Uint8Array): (cleartext: Uint8Array, aad?: Uint8Array) => EncryptionResult {\n  const cipher = new XChaCha20Poly1305(key)\n  return (cleartext: Uint8Array, aad?: Uint8Array) => {\n    const iv = randomBytes(cipher.nonceLength)\n    const sealed = cipher.seal(iv, cleartext, aad)\n    return {\n      ciphertext: sealed.subarray(0, sealed.length - cipher.tagLength),\n      tag: sealed.subarray(sealed.length - cipher.tagLength),\n      iv\n    }\n  }\n}\n\nexport function xc20pDirEncrypter(key: Uint8Array): Encrypter {\n  const xc20pEncrypt = xc20pEncrypter(key)\n  const enc = 'XC20P'\n  const alg = 'dir'\n  async function encrypt(cleartext, protectedHeader = {}, aad?): Promise<EncryptionResult> {\n    const protHeader = encodeBase64url(JSON.stringify(Object.assign({ alg }, protectedHeader, { enc })))\n    const encodedAad = new Uint8Array(Buffer.from(aad ? `${protHeader}.${bytesToBase64url(aad)}` : protHeader))\n    return {\n      ...xc20pEncrypt(cleartext, encodedAad),\n      protectedHeader: protHeader\n    }\n  }\n  return { alg, enc, encrypt }\n}\n\nexport function xc20pDirDecrypter(key: Uint8Array): Decrypter {\n  const cipher = new XChaCha20Poly1305(key)\n  async function decrypt(sealed, iv, aad?): Promise<Uint8Array> {\n    return cipher.open(iv, sealed, aad)\n  }\n  return { alg: 'dir', enc: 'XC20P', decrypt }\n}\n\nexport function x25519Encrypter(publicKey: Uint8Array, kid?: string): Encrypter {\n  const alg = 'ECDH-ES+XC20PKW'\n  const keyLen = 256\n  const crv = 'X25519'\n  async function encryptCek(cek): Promise<Recipient> {\n    const epk = generateKeyPair()\n    const sharedSecret = sharedKey(epk.secretKey, publicKey)\n    // Key Encryption Key\n    const kek = concatKDF(sharedSecret, keyLen, alg)\n    const res = xc20pEncrypter(kek)(cek)\n    const recipient: Recipient = {\n      encrypted_key: bytesToBase64url(res.ciphertext),\n      header: {\n        alg,\n        iv: bytesToBase64url(res.iv),\n        tag: bytesToBase64url(res.tag),\n        epk: { kty: 'OKP', crv, x: bytesToBase64url(epk.publicKey) }\n      }\n    }\n    if (kid) recipient.header.kid = kid\n    return recipient\n  }\n  async function encrypt(cleartext, protectedHeader = {}, aad?): Promise<EncryptionResult> {\n    // we won't want alg to be set to dir from xc20pDirEncrypter\n    Object.assign(protectedHeader, { alg: undefined })\n    // Content Encryption Key\n    const cek = randomBytes(32)\n    return {\n      ...(await xc20pDirEncrypter(cek).encrypt(cleartext, protectedHeader, aad)),\n      recipient: await encryptCek(cek),\n      cek\n    }\n  }\n  return { alg, enc: 'XC20P', encrypt, encryptCek }\n}\n\n/**\n * Implements ECDH-1PU+XC20PKW with XChaCha20Poly1305 based on the following specs:\n *   - [XC20PKW](https://tools.ietf.org/html/draft-amringer-jose-chacha-02)\n *   - [ECDH-1PU](https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03)\n */\nexport function xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2(\n  recipientPublicKey: Uint8Array,\n  senderSecretKey: Uint8Array,\n  options: Partial<AuthEncryptParams> = {}\n): Encrypter {\n  const alg = 'ECDH-1PU+XC20PKW'\n  const keyLen = 256\n  const crv = 'X25519'\n\n  let partyUInfo\n  let partyVInfo\n  if (options.apu !== undefined) partyUInfo = base64ToBytes(options.apu)\n  if (options.apv !== undefined) partyVInfo = base64ToBytes(options.apv)\n\n  async function encryptCek(cek): Promise<Recipient> {\n    const epk = generateKeyPair()\n    const zE = sharedKey(epk.secretKey, recipientPublicKey)\n\n    // ECDH-1PU requires additional shared secret between\n    // static key of sender and static key of recipient\n    const zS = sharedKey(senderSecretKey, recipientPublicKey)\n\n    const sharedSecret = new Uint8Array(zE.length + zS.length)\n    sharedSecret.set(zE)\n    sharedSecret.set(zS, zE.length)\n\n    // Key Encryption Key\n    const kek = concatKDF(sharedSecret, keyLen, alg, partyUInfo, partyVInfo)\n\n    const res = xc20pEncrypter(kek)(cek)\n    const recipient: Recipient = {\n      encrypted_key: bytesToBase64url(res.ciphertext),\n      header: {\n        alg,\n        iv: bytesToBase64url(res.iv),\n        tag: bytesToBase64url(res.tag),\n        epk: { kty: 'OKP', crv, x: bytesToBase64url(epk.publicKey) }\n      }\n    }\n    if (options.kid) recipient.header.kid = options.kid\n    if (options.apu) recipient.header.apu = options.apu\n    if (options.apv) recipient.header.apv = options.apv\n\n    return recipient\n  }\n  async function encrypt(cleartext, protectedHeader = {}, aad?): Promise<EncryptionResult> {\n    // we won't want alg to be set to dir from xc20pDirEncrypter\n    Object.assign(protectedHeader, { alg: undefined, skid: options.skid })\n    // Content Encryption Key\n    const cek = randomBytes(32)\n    return {\n      ...(await xc20pDirEncrypter(cek).encrypt(cleartext, protectedHeader, aad)),\n      recipient: await encryptCek(cek),\n      cek\n    }\n  }\n  return { alg, enc: 'XC20P', encrypt, encryptCek }\n}\n\nexport async function resolveX25519Encrypters(dids: string[], resolver: Resolvable): Promise<Encrypter[]> {\n  const encryptersForDID = async (did): Promise<Encrypter[]> => {\n    const { didResolutionMetadata, didDocument } = await resolver.resolve(did)\n    if (didResolutionMetadata?.error) {\n      throw new Error(\n        `Could not find x25519 key for ${did}: ${didResolutionMetadata.error}, ${didResolutionMetadata.message}`\n      )\n    }\n    if (!didDocument.keyAgreement) throw new Error(`Could not find x25519 key for ${did}`)\n    const agreementKeys: VerificationMethod[] = didDocument.keyAgreement?.map((key) => {\n      if (typeof key === 'string') {\n        return [...(didDocument.publicKey || []), ...(didDocument.verificationMethod || [])].find((pk) => pk.id === key)\n      }\n      return key\n    })\n    const pks = agreementKeys.filter((key) => {\n      return key.type === 'X25519KeyAgreementKey2019' && Boolean(key.publicKeyBase58)\n    })\n    if (!pks.length) throw new Error(`Could not find x25519 key for ${did}`)\n    return pks.map((pk) => x25519Encrypter(base58ToBytes(pk.publicKeyBase58), pk.id))\n  }\n\n  const encrypterPromises = dids.map((did) => encryptersForDID(did))\n  const encrypterArrays = await Promise.all(encrypterPromises)\n\n  return flatten(encrypterArrays)\n}\n\nfunction validateHeader(header: Record<string, any>) {\n  if (!(header.epk && header.iv && header.tag)) {\n    throw new Error('Invalid JWE')\n  }\n}\n\nexport function x25519Decrypter(secretKey: Uint8Array): Decrypter {\n  const alg = 'ECDH-ES+XC20PKW'\n  const keyLen = 256\n  const crv = 'X25519'\n  async function decrypt(sealed, iv, aad, recipient): Promise<Uint8Array> {\n    validateHeader(recipient.header)\n    if (recipient.header.epk.crv !== crv) return null\n    const publicKey = base64ToBytes(recipient.header.epk.x)\n    const sharedSecret = sharedKey(secretKey, publicKey)\n\n    // Key Encryption Key\n    const kek = concatKDF(sharedSecret, keyLen, alg)\n    // Content Encryption Key\n    const sealedCek = toSealed(recipient.encrypted_key, recipient.header.tag)\n    const cek = await xc20pDirDecrypter(kek).decrypt(sealedCek, base64ToBytes(recipient.header.iv))\n    if (cek === null) return null\n\n    return xc20pDirDecrypter(cek).decrypt(sealed, iv, aad)\n  }\n  return { alg, enc: 'XC20P', decrypt }\n}\n\n/**\n * Implements ECDH-1PU+XC20PKW with XChaCha20Poly1305 based on the following specs:\n *   - [XC20PKW](https://tools.ietf.org/html/draft-amringer-jose-chacha-02)\n *   - [ECDH-1PU](https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03)\n */\nexport function xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2(\n  recipientSecretKey: Uint8Array,\n  senderPublicKey: Uint8Array\n): Decrypter {\n  const alg = 'ECDH-1PU+XC20PKW'\n  const keyLen = 256\n  const crv = 'X25519'\n  async function decrypt(sealed, iv, aad, recipient): Promise<Uint8Array> {\n    validateHeader(recipient.header)\n    if (recipient.header.epk.crv !== crv) return null\n    // ECDH-1PU requires additional shared secret between\n    // static key of sender and static key of recipient\n    const publicKey = base64ToBytes(recipient.header.epk.x)\n    const zE = sharedKey(recipientSecretKey, publicKey)\n    const zS = sharedKey(recipientSecretKey, senderPublicKey)\n\n    const sharedSecret = new Uint8Array(zE.length + zS.length)\n    sharedSecret.set(zE)\n    sharedSecret.set(zS, zE.length)\n\n    // Key Encryption Key\n    let producerInfo\n    let consumerInfo\n    if (recipient.header.apu) producerInfo = base64ToBytes(recipient.header.apu)\n    if (recipient.header.apv) consumerInfo = base64ToBytes(recipient.header.apv)\n\n    const kek = concatKDF(sharedSecret, keyLen, alg, producerInfo, consumerInfo)\n    // Content Encryption Key\n    const sealedCek = toSealed(recipient.encrypted_key, recipient.header.tag)\n    const cek = await xc20pDirDecrypter(kek).decrypt(sealedCek, base64ToBytes(recipient.header.iv))\n    if (cek === null) return null\n\n    return xc20pDirDecrypter(cek).decrypt(sealed, iv, aad)\n  }\n  return { alg, enc: 'XC20P', decrypt }\n}\n"],"names":["bytesToBase64url","b","u8a","base64ToBytes","s","inputBase64Url","replace","base58ToBytes","hexToBytes","input","startsWith","substring","toLowerCase","encodeBase64url","decodeBase64url","bytesToHex","stringToBytes","toJose","r","recoveryParam","recoverable","jose","Uint8Array","set","undefined","Error","fromJose","signature","signatureBytes","length","TypeError","slice","toSealed","ciphertext","tag","hexMatcher","base58Matcher","base64Matcher","parseKey","test","leftpad","data","size","repeat","sha256","payload","hash","toEthereumAddress","hexPublicKey","hashInput","keccak_256","arrayBuffer","writeUint32BE","value","array","encoded","toString","lengthAndInput","concatKDF","secret","keyLen","alg","producerInfo","consumerInfo","secp256k1","EC","ES256KSigner","privateKey","privateKeyBytes","keyPair","keyFromPrivate","sign","SimpleSigner","hexPrivateKey","signer","EllipticSigner","EdDSASigner","secretKey","dataBytes","sig","NaclSigner","base64PrivateKey","instanceOfEcdsaSignature","object","ES256KSignerAlg","Ed25519SignerAlg","algorithms","ES256K","ES256K-R","Ed25519","EdDSA","toSignatureObject","rawsig","sigObj","extractPublicKeyBytes","pk","publicKeyBase58","publicKeyBase64","publicKeyHex","publicKeyJwk","crv","keyFromPublic","x","y","getPublic","verifyRecoverableES256K","authenticators","signatures","so","map","recoveredKey","recoverPubKey","recoveredPublicKeyHex","encode","recoveredCompressedPublicKeyHex","recoveredAddress","find","keyHex","ethereumAddress","blockchainAccountId","split","filter","key","verifyEd25519","clear","verify","fullPublicKeys","ethAddressKeys","pubBytes","err","VerifierAlgorithm","impl","verifyJWT","jwt","options","resolver","auth","audience","callbackUrl","skewTime","proofPurpose","header","decodeJWT","hasOwnProperty","issuer","types","SUPPORTED_PUBLIC_KEY_TYPES","didResult","resolve","accept","DID_JSON","result","Object","getOwnPropertyNames","indexOf","didDocument","didDocumentMetadata","didResolutionMetadata","contentType","error","message","getPublicKeyById","verificationMethods","pubid","filtered","id","publicKeysToCheck","verificationMethod","publicKey","assertionMethod","type","supported","didResolutionResult","resolveAuthenticator","iss","verifyJWSDecoded","now","Math","floor","Date","NBF_SKEW","nowSkewed","nbf","iat","exp","aud","Array","isArray","item","createJWT","expiresIn","canonicalize","typ","timestamps","fullPayload","createJWS","defaultAlg","encodedPayload","encodeSection","signingInput","join","jwtSigner","SignerAlg","shouldCanonicalize","canonicalizeData","JSON","stringify","decodeJWS","jws","parts","match","parse","assign","e","pubkeys","verifyJWS","decryptJWE","jwe","decrypter","cleartext","protected","iv","recipients","rec","encrypted_key","validateJWE","protHeader","enc","sealed","aad","Buffer","from","decrypt","i","recipient","bind","pact","_settle","state","onFulfilled","_this","onRejected","encodeJWE","protectedHeader","createJWE","encrypters","encrypt","encryptionResult","tmpEnc","reduce","acc","encrypter","cek","_jwe$recipients","push","encryptCek","_push","resolveX25519Encrypters","dids","encryptersForDID","did","keyAgreement","pks","Boolean","x25519Encrypter","encrypterPromises","Promise","all","flatten","arrays","concat","apply","createAuthEncrypter","recipientPublicKey","senderSecretKey","xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2","createAnonEncrypter","kid","createAuthDecrypter","recipientSecretKey","senderPublicKey","xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2","createAnonDecrypter","x25519Decrypter","xc20pEncrypter","cipher","XChaCha20Poly1305","randomBytes","nonceLength","seal","subarray","tagLength","xc20pDirEncrypter","xc20pEncrypt","encodedAad","xc20pDirDecrypter","open","epk","generateKeyPair","res","sharedKey","kty","zE","zS","sharedSecret","partyUInfo","partyVInfo","apu","apv","skid","validateHeader","kek","sealedCek"],"mappings":"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"}