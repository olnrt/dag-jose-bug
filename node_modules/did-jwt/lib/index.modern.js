import{toString as e,fromString as r,concat as t}from"uint8arrays";import{hash as n}from"@stablelib/sha256";import{keccak_256 as i}from"js-sha3";import{ec as o}from"elliptic";import{sign as a,verify as c}from"@stablelib/ed25519";import s from"canonicalize";import{XChaCha20Poly1305 as u}from"@stablelib/xchacha20poly1305";import{generateKeyPair as l,sharedKey as d}from"@stablelib/x25519";import{randomBytes as f}from"@stablelib/random";function p(r){return e(r,"base64url")}function y(e){const t=e.replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"");return r(t,"base64url")}function h(e){return r(e,"base58btc")}function g(e){const t=e.startsWith("0x")?e.substring(2):e;return r(t.toLowerCase(),"base16")}function w(e){return p(r(e))}function v(r){return e(y(r))}function b(r){return e(r,"base16")}function m(e){return r(e)}function E({r:e,s:t,recoveryParam:n},i){const o=new Uint8Array(i?65:64);if(o.set(r(e,"base16"),0),o.set(r(t,"base16"),32),i){if(void 0===n)throw new Error("Signer did not return a recoveryParam");o[64]=n}return p(o)}function k(e){const r=y(e);if(r.length<64||r.length>65)throw new TypeError(`Wrong size for signature. Expected 64 or 65 bytes, but got ${r.length}`);return{r:b(r.slice(0,32)),s:b(r.slice(32,64)),recoveryParam:65===r.length?r[64]:void 0}}function K(e,r){return t([y(e),y(r)])}const x=/^(0x)?([a-fA-F0-9]{64}|[a-fA-F0-9]{128})$/,S=/^([1-9A-HJ-NP-Za-km-z]{44}|[1-9A-HJ-NP-Za-km-z]{88})$/,P=/^([0-9a-zA-Z=\-_\+\/]{43}|[0-9a-zA-Z=\-_\+\/]{86})(={0,2})$/;function A(e){if("string"==typeof e){if(x.test(e))return g(e);if(S.test(e))return h(e);if(P.test(e))return y(e);throw TypeError("Invalid private key format")}if(e instanceof Uint8Array)return e;throw TypeError("Invalid private key format")}function $(e,r=64){return e.length===r?e:"0".repeat(r-e.length)+e}function D(e){const t="string"==typeof e?r(e):e;return n(t)}function J(t){const n=r(t.slice(2),"base16");return`0x${e((o=n,new Uint8Array(i.arrayBuffer(o))).slice(-20),"base16")}`;var o}function W(e,t=new Uint8Array(4)){const n=r(e.toString(),"base10");return t.set(n,4-n.length),t}const C=e=>t([W(e.length),e]);function I(e,i,o,a,c){if(256!==i)throw new Error(`Unsupported key length: ${i}`);const s=t([C(r(o)),C(void 0===a?new Uint8Array(0):a),C(void 0===c?new Uint8Array(0):c),W(i)]);return n(t([W(1),e,s]))}const O=new o("secp256k1");function T(e,r=!1){const t=A(e);if(32!==t.length)throw new Error(`Invalid private key format. Expecting 32 bytes, but got ${t.length}`);const n=O.keyFromPrivate(t);return async e=>{const{r:t,s:i,recoveryParam:o}=n.sign(D(e));return E({r:$(t.toString("hex")),s:$(i.toString("hex")),recoveryParam:o},r)}}function U(e){const r=T(e,!0);return async e=>k(await r(e))}function j(e){return T(e)}function R(e){const r=A(e);if(64!==r.length)throw new Error(`Invalid private key format. Expecting 64 bytes, but got ${r.length}`);return async e=>{const t="string"==typeof e?m(e):e;return p(a(r,t))}}function X(e){return R(e)}function M(){return(M=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e}).apply(this,arguments)}function z(e){return"object"==typeof e&&"r"in e&&"s"in e}function N(e){return async function(r,t){const n=await t(r);if(z(n))return E(n,e);if(e&&void 0===k(n).recoveryParam)throw new Error("ES256K-R not supported when signer doesn't provide a recovery param");return n}}function _(){return async function(e,r){const t=await r(e);if(z(t))throw new Error("expected a signer function that returns a string instead of signature object");return t}}const B={ES256K:N(),"ES256K-R":N(!0),Ed25519:_(),EdDSA:_()},H=new o("secp256k1");function V(e,r=!1){const t=y(e);if(t.length!==(r?65:64))throw new Error("wrong signature length");const n={r:b(t.slice(0,32)),s:b(t.slice(32,64))};return r&&(n.recoveryParam=t[64]),n}function Z(e){return e.publicKeyBase58?h(e.publicKeyBase58):e.publicKeyBase64?y(e.publicKeyBase64):e.publicKeyHex?g(e.publicKeyHex):e.publicKeyJwk&&"secp256k1"===e.publicKeyJwk.crv?g(H.keyFromPublic({x:b(y(e.publicKeyJwk.x)),y:b(y(e.publicKeyJwk.y))}).getPublic("hex")):new Uint8Array}function F(e,r,t){let n;if(r.length>86)n=[V(r,!0)];else{const e=V(r,!1);n=[M({},e,{recoveryParam:0}),M({},e,{recoveryParam:1})]}const i=n.map(r=>{const n=D(e),i=H.recoverPubKey(n,r,r.recoveryParam),o=i.encode("hex"),a=i.encode("hex",!0),c=J(o);return t.find(e=>{var r,t,n;const i=b(Z(e));return i===o||i===a||(null==(r=e.ethereumAddress)?void 0:r.toLowerCase())===c||(null==(t=e.blockchainAccountId)||null==(n=t.split("@eip155"))?void 0:n[0].toLowerCase())===c})}).filter(e=>null!=e);if(0===i.length)throw new Error("Signature invalid for JWT");return i[0]}function L(e,r,t){const n=m(e),i=y(r),o=t.find(e=>c(Z(e),n,i));if(!o)throw new Error("Signature invalid for JWT");return o}const q={ES256K:function(e,r,t){const n=D(e),i=V(r),o=t.filter(({ethereumAddress:e,blockchainAccountId:r})=>void 0===e&&void 0===r),a=t.filter(({ethereumAddress:e,blockchainAccountId:r})=>void 0!==e||void 0!==typeof r);let c=o.find(e=>{try{const r=Z(e);return H.keyFromPublic(r).verify(n,i)}catch(e){return!1}});if(!c&&a.length>0&&(c=F(e,r,a)),!c)throw new Error("Signature invalid for JWT");return c},"ES256K-R":F,Ed25519:L,EdDSA:L};function G(e){const r=q[e];if(!r)throw new Error(`Unsupported algorithm ${e}`);return r}G.toSignatureObject=V;const Q={ES256K:["EcdsaSecp256k1VerificationKey2019","EcdsaSecp256k1RecoveryMethod2020","Secp256k1VerificationKey2018","Secp256k1SignatureVerificationKey2018","EcdsaPublicKeySecp256k1"],"ES256K-R":["EcdsaSecp256k1VerificationKey2019","EcdsaSecp256k1RecoveryMethod2020","Secp256k1VerificationKey2018","Secp256k1SignatureVerificationKey2018","EcdsaPublicKeySecp256k1"],Ed25519:["ED25519SignatureVerification","Ed25519VerificationKey2018"],EdDSA:["ED25519SignatureVerification","Ed25519VerificationKey2018"]};function Y(e,r=!1){return w(r?s(e):JSON.stringify(e))}function ee(e){const r=e.match(/^([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);if(r)return{header:JSON.parse(v(r[1])),payload:r[2],signature:r[3],data:`${r[1]}.${r[2]}`};throw new Error("Incorrect format JWS")}function re(e){if(!e)throw new Error("no JWT passed into decodeJWT");try{const r=ee(e);return Object.assign(r,{payload:JSON.parse(v(r.payload))})}catch(e){throw new Error("Incorrect format JWT")}}async function te(e,r,t={},n={}){t.alg||(t.alg="ES256K");const i="string"==typeof e?e:Y(e,n.canonicalize),o=[Y(t,n.canonicalize),i].join("."),a=function(e){const r=B[e];if(!r)throw new Error(`Unsupported algorithm ${e}`);return r}(t.alg);return[o,await a(o,r)].join(".")}async function ne(e,{issuer:r,signer:t,alg:n,expiresIn:i,canonicalize:o},a={}){if(!t)throw new Error("No Signer functionality has been configured");if(!r)throw new Error("No issuing DID has been configured");a.typ||(a.typ="JWT"),a.alg||(a.alg=n);const c={iat:Math.floor(Date.now()/1e3),exp:void 0};if(i){if("number"!=typeof i)throw new Error("JWT expiresIn is not a number");c.exp=(e.nbf||c.iat)+Math.floor(i)}return te(M({},c,e,{iss:r}),t,a,{canonicalize:o})}function ie({header:e,data:r,signature:t},n){return Array.isArray(n)||(n=[n]),G(e.alg)(r,t,n)}function oe(e,r){return ie(ee(e),r)}async function ae(e,r={resolver:null,auth:null,audience:null,callbackUrl:null,skewTime:null,proofPurpose:null}){if(!r.resolver)throw new Error("No DID resolver has been configured");const{payload:t,header:n,signature:i,data:o}=re(e),a=r.hasOwnProperty("auth")?r.auth?"authentication":void 0:r.proofPurpose,{didResolutionResult:c,authenticators:s,issuer:u}=await async function(e,r,t,n){var i,o,a,c,s;const u=Q[r];if(!u||0===u.length)throw new Error(`No supported signature types for algorithm ${r}`);let l;const d=await e.resolve(t,{accept:"application/did+json"});if(l=-1===Object.getOwnPropertyNames(d).indexOf("didDocument")?{didDocument:d,didDocumentMetadata:{},didResolutionMetadata:{contentType:"application/did+json"}}:d,null!=(i=l.didResolutionMetadata)&&i.error){const{error:e,message:r}=l.didResolutionMetadata;throw new Error(`Unable to resolve DID document for ${t}: ${e}, ${r||""}`)}const f=(e,r)=>{const t=e.filter(({id:e})=>r===e);return t.length>0?t[0]:null};let p=[...(null==(o=l)||null==(a=o.didDocument)?void 0:a.verificationMethod)||[],...(null==(c=l)||null==(s=c.didDocument)?void 0:s.publicKey)||[]];"string"==typeof n&&(n.startsWith("assertion")&&!l.didDocument.hasOwnProperty("assertionMethod")&&(l.didDocument.assertionMethod=[...p.map(e=>e.id)]),p=(l.didDocument[n]||[]).map(e=>"string"==typeof e?f(p,e):"string"==typeof e.publicKey?f(p,e.publicKey):e).filter(e=>null!=e));const y=p.filter(({type:e})=>u.find(r=>r===e));if("string"==typeof n&&(!y||0===y.length))throw new Error(`DID document for ${t} does not have public keys suitable for ${r} with ${n} purpose`);if(!y||0===y.length)throw new Error(`DID document for ${t} does not have public keys for ${r}`);return{authenticators:y,issuer:t,didResolutionResult:l}}(r.resolver,n.alg,t.iss,a),l=await ie({header:n,data:o,signature:i},s),d=Math.floor(Date.now()/1e3),f=r.skewTime>=0?r.skewTime:300;if(l){const n=d+f;if(t.nbf){if(t.nbf>n)throw new Error(`JWT not valid before nbf: ${t.nbf}`)}else if(t.iat&&t.iat>n)throw new Error(`JWT not valid yet (issued in the future) iat: ${t.iat}`);if(t.exp&&t.exp<=d-f)throw new Error(`JWT has expired: exp: ${t.exp} < now: ${d}`);if(t.aud){if(!r.audience&&!r.callbackUrl)throw new Error("JWT audience is required but your app address has not been configured");if(void 0===(Array.isArray(t.aud)?t.aud:[t.aud]).find(e=>r.audience===e||r.callbackUrl===e))throw new Error("JWT audience does not match your DID or callback url")}return{payload:t,didResolutionResult:c,issuer:u,signer:l,jwt:e}}}function ce({ciphertext:e,tag:r,iv:t,protectedHeader:n,recipient:i},o){const a={protected:n,iv:p(t),ciphertext:p(e),tag:p(r)};return o&&(a.aad=p(o)),i&&(a.recipients=[i]),a}async function se(e,r,t={},n){if("dir"===r[0].alg){if(r.length>1)throw new Error('Can only do "dir" encryption to one key.');return ce(await r[0].encrypt(e,t,n),n)}{const i=r[0].enc;if(!r.reduce((e,r)=>e&&r.enc===i,!0))throw new Error("Incompatible encrypters passed");let o,a;for(const i of r)if(o)a.recipients.push(await i.encryptCek(o));else{const r=await i.encrypt(e,t,n);o=r.cek,a=ce(r,n)}return a}}async function ue(e,r){!function(e){if(!(e.protected&&e.iv&&e.ciphertext&&e.tag))throw new Error("Invalid JWE");e.recipients&&e.recipients.map(e=>{if(!e.header||!e.encrypted_key)throw new Error("Invalid JWE")})}(e);const t=JSON.parse(v(e.protected));if(t.enc!==r.enc)throw new Error(`Decrypter does not support: '${t.enc}'`);const n=K(e.ciphertext,e.tag),i=new Uint8Array(Buffer.from(e.aad?`${e.protected}.${e.aad}`:e.protected));let o=null;if("dir"===t.alg&&"dir"===r.alg)o=await r.decrypt(n,y(e.iv),i);else{if(!e.recipients||0===e.recipients.length)throw new Error("Invalid JWE");for(let a=0;!o&&a<e.recipients.length;a++){const c=e.recipients[a];Object.assign(c.header,t),c.header.alg===r.alg&&(o=await r.decrypt(n,y(e.iv),i,c))}}if(null===o)throw new Error("Failed to decrypt");return o}function le(e,r,t={}){return ve(e,r,t)}function de(e,r={}){return void 0!==r?we(e,r.kid):we(e)}function fe(e,r){return ke(e,r)}function pe(e){return Ee(e)}function ye(e){const r=new u(e);return(e,t)=>{const n=f(r.nonceLength),i=r.seal(n,e,t);return{ciphertext:i.subarray(0,i.length-r.tagLength),tag:i.subarray(i.length-r.tagLength),iv:n}}}function he(e){const r=ye(e),t="XC20P";return{alg:"dir",enc:t,encrypt:async function(e,n={},i){const o=w(JSON.stringify(Object.assign({alg:"dir"},n,{enc:t}))),a=new Uint8Array(Buffer.from(i?`${o}.${p(i)}`:o));return M({},r(e,a),{protectedHeader:o})}}}function ge(e){const r=new u(e);return{alg:"dir",enc:"XC20P",decrypt:async function(e,t,n){return r.open(t,e,n)}}}function we(e,r){const t="ECDH-ES+XC20PKW";async function n(n){const i=l(),o=ye(I(d(i.secretKey,e),256,t))(n),a={encrypted_key:p(o.ciphertext),header:{alg:t,iv:p(o.iv),tag:p(o.tag),epk:{kty:"OKP",crv:"X25519",x:p(i.publicKey)}}};return r&&(a.header.kid=r),a}return{alg:t,enc:"XC20P",encrypt:async function(e,r={},t){Object.assign(r,{alg:void 0});const i=f(32);return M({},await he(i).encrypt(e,r,t),{recipient:await n(i),cek:i})},encryptCek:n}}function ve(e,r,t={}){const n="ECDH-1PU+XC20PKW";let i,o;async function a(a){const c=l(),s=d(c.secretKey,e),u=d(r,e),f=new Uint8Array(s.length+u.length);f.set(s),f.set(u,s.length);const y=ye(I(f,256,n,i,o))(a),h={encrypted_key:p(y.ciphertext),header:{alg:n,iv:p(y.iv),tag:p(y.tag),epk:{kty:"OKP",crv:"X25519",x:p(c.publicKey)}}};return t.kid&&(h.header.kid=t.kid),t.apu&&(h.header.apu=t.apu),t.apv&&(h.header.apv=t.apv),h}return void 0!==t.apu&&(i=y(t.apu)),void 0!==t.apv&&(o=y(t.apv)),{alg:n,enc:"XC20P",encrypt:async function(e,r={},n){Object.assign(r,{alg:void 0,skid:t.skid});const i=f(32);return M({},await he(i).encrypt(e,r,n),{recipient:await a(i),cek:i})},encryptCek:a}}async function be(e,r){const t=e.map(e=>(async e=>{var t;const{didResolutionMetadata:n,didDocument:i}=await r.resolve(e);if(null!=n&&n.error)throw new Error(`Could not find x25519 key for ${e}: ${n.error}, ${n.message}`);if(!i.keyAgreement)throw new Error(`Could not find x25519 key for ${e}`);const o=(null==(t=i.keyAgreement)?void 0:t.map(e=>"string"==typeof e?[...i.publicKey||[],...i.verificationMethod||[]].find(r=>r.id===e):e)).filter(e=>"X25519KeyAgreementKey2019"===e.type&&Boolean(e.publicKeyBase58));if(!o.length)throw new Error(`Could not find x25519 key for ${e}`);return o.map(e=>we(h(e.publicKeyBase58),e.id))})(e)),n=await Promise.all(t);return[].concat.apply([],n)}function me(e){if(!(e.epk&&e.iv&&e.tag))throw new Error("Invalid JWE")}function Ee(e){const r="ECDH-ES+XC20PKW";return{alg:r,enc:"XC20P",decrypt:async function(t,n,i,o){if(me(o.header),"X25519"!==o.header.epk.crv)return null;const a=y(o.header.epk.x),c=I(d(e,a),256,r),s=K(o.encrypted_key,o.header.tag),u=await ge(c).decrypt(s,y(o.header.iv));return null===u?null:ge(u).decrypt(t,n,i)}}}function ke(e,r){const t="ECDH-1PU+XC20PKW";return{alg:t,enc:"XC20P",decrypt:async function(n,i,o,a){if(me(a.header),"X25519"!==a.header.epk.crv)return null;const c=y(a.header.epk.x),s=d(e,c),u=d(e,r),l=new Uint8Array(s.length+u.length);let f,p;l.set(s),l.set(u,s.length),a.header.apu&&(f=y(a.header.apu)),a.header.apv&&(p=y(a.header.apv));const h=I(l,256,t,f,p),g=K(a.encrypted_key,a.header.tag),w=await ge(h).decrypt(g,y(a.header.iv));return null===w?null:ge(w).decrypt(n,i,o)}}}export{T as ES256KSigner,R as EdDSASigner,j as EllipticSigner,X as NaclSigner,U as SimpleSigner,pe as createAnonDecrypter,de as createAnonEncrypter,fe as createAuthDecrypter,le as createAuthEncrypter,se as createJWE,te as createJWS,ne as createJWT,re as decodeJWT,ue as decryptJWE,be as resolveX25519Encrypters,J as toEthereumAddress,oe as verifyJWS,ae as verifyJWT,Ee as x25519Decrypter,we as x25519Encrypter,ke as xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2,ve as xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2,ge as xc20pDirDecrypter,he as xc20pDirEncrypter};
//# sourceMappingURL=index.modern.js.map
