/**
 * <T>
 */
export type IPLDFormat<T> = import('interface-ipld-format').Format<T>;
/**
 * <Code, T>
 */
export type BlockCodec<Code, T> = import('multiformats/codecs/interface').BlockCodec<Code, T>;
/**
 * @template T
 * @typedef {import('interface-ipld-format').Format<T>} IPLDFormat<T>
 */
/**
 * @template Code
 * @template T
 * @typedef {import('multiformats/codecs/interface').BlockCodec<Code, T>} BlockCodec<Code, T>
 */
/**
 * Converts a BlockFormat from the multiformats module into
 * an IPLD Format
 *
 * @template Code
 * @template T
 *
 * @param {BlockCodec<Code, T>} blockCodec
 *
 * @param {object} [options]
 * @param {import('multihashes').HashName} [options.defaultHashAlg]
 * @param {IPLDFormat<T>["resolver"]["resolve"]} [options.resolve]
 * @param {IPLDFormat<T>["resolver"]["tree"]} [options.tree]
 */
export function convert<Code, T>(blockCodec: import("multiformats/codecs/interface").BlockCodec<Code, T>, options?: {
    defaultHashAlg?: mha.multihash.HashName | undefined;
    resolve?: ((binaryBlob: Uint8Array, path: string) => {
        value: any;
        remainderPath: string;
    }) | undefined;
    tree?: ((binaryBlob: Uint8Array) => Generator<string, void, undefined>) | undefined;
} | undefined): import("interface-ipld-format").Format<T>;
import mha = require("multihashing-async");
//# sourceMappingURL=index.d.ts.map